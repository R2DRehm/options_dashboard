"""simulation/correlated_paths.py

Génère des trajectoires corrélées pour :
    • le prix (GBM)
    • la variance (processus OU sur la variance ou Heston‐lite)
    • le taux court (Vasicek)

On produit :
    - un maillage *fin* (N_fine pas) pour la simulation
    - un indice de maillage *coarse* (N_coarse + 1 points) utilisé pour la prise
      de décisions (slider dans le dashboard).

Auteur : autogenerated by options‑dashboard helper
"""

from __future__ import annotations

import numpy as np
from numpy.typing import NDArray
from dataclasses import dataclass


@dataclass
class PathParams:
    """Regroupe les paramètres de simulation."""

    # Spot / drift
    mu: float = 0.05
    # Volatility OU
    kappa_v: float = 1.0
    theta_v: float = 0.04  # niveau moyen de la variance
    xi: float = 0.2  # vol du vol (sur la variance)
    # Rate Vasicek
    kappa_r: float = 0.5
    theta_r: float = 0.03
    sigma_r: float = 0.01
    # Corrélation prix‑vol
    rho: float = -0.5


def generate_paths(
    S0: float,
    V0: float,
    r0: float,
    params: PathParams,
    T: float,
    N_fine: int,
    N_coarse: int,
    seed: int | None = None,
) -> dict[str, NDArray]:
    """Simule des trajectoires corrélées (S, V, r)."""
    rng = np.random.default_rng(seed)  # <- RNG local, seed=None => aléa frais

    dt = T / N_fine
    sqrt_dt = np.sqrt(dt)

    # Corrélation (prix/vol)
    cov = np.array([[1.0, params.rho], [params.rho, 1.0]])
    L = np.linalg.cholesky(cov)

    # Pré-allocation
    S = np.empty(N_fine + 1)
    V = np.empty(N_fine + 1)
    r = np.empty(N_fine + 1)
    S[0], V[0], r[0] = S0, V0, r0

    # Tirages normaux (corrélés pour S/V, indépendants pour r)
    Z = rng.standard_normal((N_fine, 3))  # (z1,z2) pour S/V, z3 pour r

    for t in range(N_fine):
        dW_pv = L @ Z[t, :2]
        dW_price, dW_vol = dW_pv[0], dW_pv[1]
        dW_rate = Z[t, 2]

        # Vol (OU sur variance, type Heston-lite)
        V_next = (
            V[t]
            + params.kappa_v * (params.theta_v - V[t]) * dt
            + params.xi * np.sqrt(max(V[t], 0.0)) * sqrt_dt * dW_vol
        )
        V[t + 1] = max(V_next, 1e-10)

        # Spot GBM
        sigma_inst = np.sqrt(V[t])
        S[t + 1] = S[t] * np.exp((params.mu - 0.5 * sigma_inst**2) * dt + sigma_inst * sqrt_dt * dW_price)

        # Taux (Vasicek)
        r[t + 1] = (
            r[t]
            + params.kappa_r * (params.theta_r - r[t]) * dt
            + params.sigma_r * sqrt_dt * dW_rate
        )

    t_fine = np.linspace(0.0, T, N_fine + 1)
    coarse_idx = np.linspace(0, N_fine, N_coarse + 1, dtype=int)

    return {"t_fine": t_fine, "coarse_idx": coarse_idx, "S": S, "V": V, "r": r}



__all__ = ["PathParams", "generate_paths"]

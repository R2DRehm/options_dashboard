"""simulation/correlated_paths.py

Génère des trajectoires corrélées pour :
    • le prix (GBM)
    • la variance (processus OU sur la variance ou Heston‐lite)
    • le taux court (Vasicek)

On produit :
    - un maillage *fin* (N_fine pas) pour la simulation
    - un indice de maillage *coarse* (N_coarse + 1 points) utilisé pour la prise
      de décisions (slider dans le dashboard).

Auteur : autogenerated by options‑dashboard helper
"""

from __future__ import annotations

import numpy as np
from numpy.typing import NDArray
from dataclasses import dataclass


@dataclass
class PathParams:
    """Regroupe les paramètres de simulation."""

    # Spot / drift
    mu: float = 0.05
    # Volatility OU
    kappa_v: float = 1.0
    theta_v: float = 0.04  # niveau moyen de la variance
    xi: float = 0.2  # vol du vol (sur la variance)
    # Rate Vasicek
    kappa_r: float = 0.5
    theta_r: float = 0.03
    sigma_r: float = 0.01
    # Corrélation prix‑vol
    rho: float = -0.5


def generate_paths(
    S0: float,
    V0: float,
    r0: float,
    params: PathParams,
    T: float,
    N_fine: int,
    N_coarse: int,
    seed: int | None = None,
) -> dict[str, NDArray]:
    """Simule des trajectoires corrélées (S, V, r).

    Parameters
    ----------
    S0, V0, r0 : float
        Valeurs initiales pour le spot, la variance (≃ σ²) et le taux court.
    params : PathParams
        Regroupe tous les paramètres de dynamique.
    T : float
        Horizon en années.
    N_fine : int
        Nombre de pas de temps fins pour la simulation.
    N_coarse : int
        Nombre de points où l’utilisateur peut intervenir (slider).
    seed : int | None
        Graine RNG.
    """
    if seed is not None:
        np.random.seed(seed)

    dt = T / N_fine

    # Matrice de corrélation (prix/vol)
    cov = np.array([[1.0, params.rho], [params.rho, 1.0]])
    L = np.linalg.cholesky(cov)  # Cholesky pour corrélation

    # Pré‑allocation
    S = np.empty(N_fine + 1)
    V = np.empty(N_fine + 1)
    r = np.empty(N_fine + 1)
    S[0], V[0], r[0] = S0, V0, r0

    for t in range(N_fine):
        # 2 BMs corrélés pour (S, V) + 1 BM indépendant (r)
        z = np.random.normal(size=3)
        dW_price, dW_vol = L @ z[:2]
        dW_rate = z[2]

        # Vol process (OU on variance)
        V[t + 1] = (
            V[t]
            + params.kappa_v * (params.theta_v - V[t]) * dt
            + params.xi * np.sqrt(max(V[t], 0)) * np.sqrt(dt) * dW_vol
        )
        V[t + 1] = max(V[t + 1], 1e-10)  # évite négativité

        # Spot GBM avec variance instantanée V
        sigma_inst = np.sqrt(V[t])
        S[t + 1] = S[t] * np.exp(
            (params.mu - 0.5 * sigma_inst**2) * dt + sigma_inst * np.sqrt(dt) * dW_price
        )

        # Rate Vasicek
        r[t + 1] = (
            r[t]
            + params.kappa_r * (params.theta_r - r[t]) * dt
            + params.sigma_r * np.sqrt(dt) * dW_rate
        )

    # Mailles de temps
    t_fine = np.linspace(0.0, T, N_fine + 1)
    coarse_idx = np.linspace(0, N_fine, N_coarse + 1, dtype=int)

    return {
        "t_fine": t_fine,  # shape (N_fine+1,)
        "coarse_idx": coarse_idx,  # shape (N_coarse+1,)
        "S": S,  # (N_fine+1,)
        "V": V,  # (N_fine+1,)
        "r": r,  # (N_fine+1,)
    }


__all__ = ["PathParams", "generate_paths"]
